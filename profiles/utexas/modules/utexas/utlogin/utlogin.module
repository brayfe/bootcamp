<?php

/**
 * @file
 * Allows users to authenticate via UTLogin.
 *
 * See the @link http://www.utexas.edu/its/utlogin/ ITS UTLogin pages @endlink for more information about UTLogin.
 */

/**
 * The query string parameter used to signify UTLogin headers should be ignored.
 *
 * When present in the query string, UTLogin headers will be ignored. This is
 * done to prevent a race condition after logging out of UTLogin and returning
 * to this site.
 */
const UTLOGIN_SKIP_PARAMETER = 'skiputlogin';

/**
 * The human-readable name for the custom view of non-UTLogin users.
 *
 * @see utlogin_views_default_views()
 */
const UTLOGIN_VIEW_ELIGIBLE_LOCAL_USERS_HUMAN_NAME = 'Users eligible for UTLogin conversion';

/**
 * The machine name for the custom view of non-UTLogin users.
 *
 * @see utlogin_views_default_views()
 */
const UTLOGIN_VIEW_ELIGIBLE_LOCAL_USERS_MACHINE_NAME = 'utlogin_view_eligible_local_users';

/**
 * The path for the custom view of non-UTLogin users.
 *
 * @see utlogin_views_default_views()
 */
const UTLOGIN_VIEW_ELIGIBLE_LOCAL_USERS_PATH = 'admin/config/people/utlogin/convert-users';

/**
 * The URL to the external logout resource for UTLogin.
 *
 * A conditional constant depending on the existence and value of the
 * utlogin_env variable.
 */
if (strtoupper(variable_get('utlogin_env', 'PROD')) == 'QUAL') {
  define('UTLOGIN_LOGOUT_URL', 'https://utlogin-login-qual.its.utexas.edu/login/UI/Logout');
}
else {
  define('UTLOGIN_LOGOUT_URL', 'https://login.utexas.edu/login/UI/Logout');
}

/**
 * The cookie name used for UTLogin.
 *
 * A conditional constant depending on the existence and value of the
 * utlogin_env variable.
 */
if (strtoupper(variable_get('utlogin_env', 'PROD')) == 'QUAL') {

  define('UTLOGIN_COOKIE_NAME', 'utlogin-qual');
}
else {

  define('UTLOGIN_COOKIE_NAME', 'utlogin-prod');
}

/**
 * Helper function to retrieve UTLogin headers.
 *
 * The UTLogin headers/attributes that will be returned are:
 * - HTTP_UTLOGIN_AFFILIATIONCODE
 * - HTTP_UTLOGIN_EID
 * - HTTP_UTLOGIN_EIDCLASS
 * - HTTP_UTLOGIN_EMAIL
 * - HTTP_UTLOGIN_ENTITLEMENTCODE
 * - HTTP_UTLOGIN_NAME
 * - HTTP_UTLOGIN_UIN
 *
 * See the @link https://www.utexas.edu/its/help/utlogin/2254 Attributes Returned by UTLogin page @endlink for more information.
 *
 * @return array
 *   An associative array of UTLogin headers/attributes if the user has
 *   authenticated with UTLogin on the server, or an empty array otherwise.
 */
function utlogin_get_utlogin_headers() {
  // The WPA, as of 3.3.3, will not auto-clear headers to prevent spoofing if
  // the UTLogin cookie is not present, so consider any headers invalid (possibly
  // spoofed) if the cookie is missing.
  $is_valid = isset($_COOKIE[UTLOGIN_COOKIE_NAME]);
  if (!$is_valid) {
    return array();
  }

  $headers = $_SERVER;
  if (!$headers) {
    return array();
  }

  $accepted_keys = array(
    'HTTP_UTLOGIN_AFFILIATIONCODE',
    'HTTP_UTLOGIN_EID',
    'HTTP_UTLOGIN_EIDCLASS',
    'HTTP_UTLOGIN_EMAIL',
    'HTTP_UTLOGIN_ENTITLEMENTCODE',
    'HTTP_UTLOGIN_NAME',
    'HTTP_UTLOGIN_UIN',
  );

  $utlogin_headers = array();
  foreach ($accepted_keys as $k) {
    if (isset($headers[$k])) {
      $utlogin_headers[$k] = $headers[$k];
    }
  }

  return $utlogin_headers;
}

/**
 * Helper function to check if a URL is valid.
 *
 * Perform the following checks on a given URL:
 * - is non-empty
 * - is parse-able (using parse_url())
 * - uses scheme http or https
 * - is prefixed by the base root of the site, excluding scheme (i.e., is internal)
 *
 * @param string $url
 *   The URL to be checked; assumed to be an absolute URL.
 *
 * @return bool
 *   TRUE if the given URL passes all checks, or FALSE otherwise.
 */
function utlogin_is_valid_goto($url) {
  global $base_root;

  // Check that the URL is non-empty.
  if (!$url) {
    return FALSE;
  }

  // Check that the URL is parse-able with parse_url().
  $parsed_url = parse_url($url);
  if (!$parsed_url) {
    return FALSE;
  }

  // Check that the URL's scheme is http or https.
  if (!isset($parsed_url['scheme'])) {
    return FALSE;
  }
  if (strtolower($parsed_url['scheme']) != 'http' && strtolower($parsed_url['scheme']) != 'https') {
    return FALSE;
  }

  // Check that the URL is internal -- prefixed by $base_root case-insensitive.
  $schemeless_url = substr($url, strlen($parsed_url['scheme']));
  $parsed_base_root = parse_url($base_root);
  $schemeless_base_root = substr($base_root, strlen($parsed_base_root['scheme']));
  if (stripos($schemeless_url, $schemeless_base_root) !== 0) {
    return FALSE;
  }

  // Check that the URL is internal -- prefixed by base_path() case sensitive
  // (after $base_root).
  $tail_url = substr($schemeless_url, strlen($schemeless_base_root));
  if (strpos($tail_url, base_path()) !== 0) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Helper function to check for the existence of a user with a given name.
 *
 * @param string $name
 *   The name to check.
 *
 * @return bool
 *   TRUE if a user with the given name already exists, or FALSE otherwise.
 */
function utlogin_check_user_with_name_exists($name) {
  return (bool) db_query_range('SELECT 1 FROM {users} WHERE name = :name', 0, 1, array(':name' => $name))->fetchField();
}

/**
 * Helper function to check for the existence of a "utlogin" authmap for a given name.
 *
 * A user is considered to be a UTLogin user if a "utlogin" authmap record
 * exists for the user's name.
 *
 * @param string $name
 *   The name to check.
 *
 * @return bool
 *   TRUE if a "utlogin" authmap record exists for the given name, or FALSE otherwise.
 */
function utlogin_check_utlogin_authmap_exists($name) {
  $authmap_records = user_get_authmaps($name);
  if (!$authmap_records) {
    return FALSE;
  }
  if (array_key_exists('utlogin', $authmap_records)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Helper function to ensure the skip parameter is in the query string of a URL.
 *
 * The given URL is assumed to be an absolute URL.
 *
 * The skip parameter will be added to the query string of the given URL if it
 * is not already present.
 *
 * @param string $url
 *   The (absolute) URL to which the skip parameter will be set if not already
 *   present.
 *
 * @return string
 *   The given URL with the skip parameter in its query string.
 *
 * @see UTLOGIN_SKIP_PARAMETER
 */
function utlogin_set_skip_parameter($url) {
  $url = trim($url);
  $parsed_url = parse_url($url);

  // Remove the fragment for now for easy access to the query string.
  if (isset($parsed_url['fragment'])) {
    $fragment_length = strlen($parsed_url['fragment']);
    $url = substr($url, 0, -1 * $fragment_length);
  }
  if (substr($url, -1) == '#') {
    $url = substr($url, 0, -1);
  }

  if (isset($parsed_url['query'])) {
    // The URL contains a query string.

    $query_parameters = array();
    parse_str($parsed_url['query'], $query_parameters);
    if (!isset($query_parameters[UTLOGIN_SKIP_PARAMETER])) {
      // The skip parameter is not in the query string; add it.

      if (substr($url, -1) != '&') {
        $url .= '&';
      }
      $url .= UTLOGIN_SKIP_PARAMETER . '=1';
    }
    elseif ($query_parameters[UTLOGIN_SKIP_PARAMETER] !== '1') {
      // The skip parameter is in the query string but with a different value
      // than expected; set it back to the expected value.

      // Remove the current query string.
      $query_length = strlen($parsed_url['query']);
      $url = substr($url, 0, -1 * $query_length);

      // Add a newly-constructed query string with the skip parameter having the
      // expected value.
      $query_parameters[UTLOGIN_SKIP_PARAMETER] = '1';
      $url .= http_build_query($query_parameters);
    }
  }
  else {
    if (substr($url, -1) != '?') {
      $url .= '?';
    }
    $url .= UTLOGIN_SKIP_PARAMETER . '=1';
  }

  // Add the fragment back in.
  if (isset($parsed_url['fragment'])) {
    $url = $url .= '#' . $parsed_url['fragment'];
  }

  return $url;
}

/**
 * Helper function to check for the skip parameter in the request URL.
 *
 * @return bool
 *   TRUE if the skip parameter is in $_GET, or FALSE otherwise.
 *
 * @see UTLOGIN_SKIP_PARAMETER
 */
function utlogin_get_skip_parameter() {
  return array_key_exists(UTLOGIN_SKIP_PARAMETER, $_GET);
}

/**
 * Helper function to return the URL of the default logout destination.
 *
 * @return string
 *   The default logout destination in the form of an absolute URL.
 */
function utlogin_get_default_logout_destination() {
  return url(variable_get('utlogin_logout_goto', NULL), array('absolute' => TRUE));
}

/**
 * Helper function to update user attributes from UTLogin headers.
 *
 * Update the user's mail with the HTTP_UTLOGIN_EMAIL UTLogin header value.
 *
 * The update process is sensitive to the presence of the skip parameter; i.e.,
 * when the skip parameter is present, no fields are updated.
 *
 * @see utlogin_get_skip_parameter()
 * @see utlogin_get_utlogin_headers()
 */
function utlogin_update_user_attributes() {
  global $user;

  if (user_is_logged_in()) {
    if (utlogin_get_skip_parameter()) {
      $utlogin_headers = array();
    }
    else {
      $utlogin_headers = utlogin_get_utlogin_headers();
    }

    $attributes = array();
    if (isset($utlogin_headers['HTTP_UTLOGIN_EMAIL'])) {
      $attributes['mail'] = $utlogin_headers['HTTP_UTLOGIN_EMAIL'];
    }

    user_save($user, $attributes);
  }
}

/**
 * Implements hook_permission().
 */
function utlogin_permission() {
  return array(
    'administer utlogin module' => array(
      'title' => t('Administer the UTLogin Module'),
      'description' => t('Access to configure the UTLogin module settings.'),
    )
  );
}

/**
 * Implements hook_menu().
 */
function utlogin_menu() {
  // The designated UTLogin-protected resource.
  $items['user/utlogin/login'] = array(
    'page callback' => 'utlogin_user_utlogin_login_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['user/utlogin/logout'] = array(
    'page callback' => 'utlogin_user_utlogin_logout_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/people/utlogin'] = array(
    'title' => 'UTLogin',
    'description' => 'Configure settings for the UTLogin module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('utlogin_admin_form'),
    'access arguments' => array('administer utlogin module'),
    'file' => 'utlogin.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/people/utlogin/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure settings for the UTLogin module',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function utlogin_menu_alter(&$items) {
  // Re-map the standard login through a custom callback that routes
  // authentication requests through the UTLogin-protected resource.
  $items['user/login']['page callback'] = 'utlogin_user_login_page';

  // Completely remove access to the [self-]register path for all users.
  $items['user/register']['access callback'] = FALSE;

  // Only allow anonymous users and user1 to access the request password reset
  // resource.
  $items['user/password']['access callback'] = 'utlogin_anonymous_or_user1_access';

  // Override the User module's user_pass_reset() with a custom callback that
  // verifies the one-time login link is for user1.
  $items['user/reset/%/%/%']['page arguments'] = array('utlogin_user_pass_reset', 2, 3, 4);
}

/**
 * Implements hook_block_info().
 */
function utlogin_block_info() {
  $blocks = array();

  // Add a UTLogin authentication block (shows UTLogin login and logout links).
  $block = array(
    'info' => t('UTLogin authentication'),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['utlogin_authentication'] = $block;

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function utlogin_block_view($delta = '') {
  global $user;

  switch ($delta) {
    case 'utlogin_authentication':
      // Define the content and behavior of the UTLogin authentication block.

      // Suppress the block for user1.
      if ($user->uid == 1) {
        return array();
      }

      $content = '';
      if (user_is_logged_in()) {
        $content .= '<p>' . t('Logged in as: @username', array('@username' => $user->name)) . '<br />'
          . l(t('Log out'), 'user/logout') . '</p>';
      }
      else {
        // Construct the current path and query string as a redirect destination
        // after login. Strip off the skip parameter if it's present so UTLogin
        // headers won't be ignored.
        $query_params = drupal_get_query_parameters();
        if (array_key_exists(UTLOGIN_SKIP_PARAMETER, $query_params)) {
          unset($query_params[UTLOGIN_SKIP_PARAMETER]);
        }
        $destination = substr(url(request_path(), array('query' => $query_params)), strlen(base_path()));

        $content .= '<p>' . l(t('Log in with UT EID'), 'user/login', array('query' => array('destination' => $destination))) . '</p>';
      }

      return array(
        'subject' => t('UTLogin'),
        'content' => $content,
      );
  }

  return array();
}

/**
 * Implements hook_block_view_MODULE_DELTA_alter().
 *
 * Forcibly suppress the User module's login block.
 */
function utlogin_block_view_user_login_alter(&$data, $block) {
  $data = NULL;
}

/**
 * Page callback: Redirects after UTLogin authentication (handled externally).
 *
 * Assuming all external systems are set up and configured correctly, the user
 * must have authenticated with UTLogin to reach this page callback (even if the
 * user is authenticated internally as user1).
 *
 * This page callback makes use of user_login_name_validate() to display a
 * message if the user is blocked and then redirects to a location specified in
 * a "goto" URL parameter. If the parameter is invalid or not present, the user
 * is instead redirected to the front page.
 *
 * @see user_login_name_validate()
 * @see utlogin_is_valid_goto()
 * @see utlogin_menu()
 */
function utlogin_user_utlogin_login_page() {
  global $user;

  // Check for non-user1 blocked status here, so the error message will only
  // appear when trying to log in.
  if ($user->uid != 1) {
    $utlogin_headers = utlogin_get_utlogin_headers();
    if ($utlogin_headers) {
      // Create a fake form to use with user_login_name_validate(), which checks
      // for blocked status and sets a message if the user is blocked.
      $state = array('values' => array('name' => $utlogin_headers['HTTP_UTLOGIN_EID']));
      user_login_name_validate(array(), $state);
    }
  }

  $goto = '';
  if (isset($_GET['goto'])) {
    // Break the goto into its components before building it back together with
    // url(). This prevents special character mangling when Clean URLs is enabled.
    $tokens = drupal_parse_url($_GET['goto']);
    $goto = url($tokens['path'], array('absolute' => TRUE, 'query' => $tokens['query'], 'fragment' => $tokens['fragment']));
  }

  // Ensure the destination after login is valid (not empty and internal).
  if (!utlogin_is_valid_goto($goto)) {
    $goto = url(NULL, array('absolute' => TRUE));
  }

  drupal_goto($goto);
}

/**
 * Page callback: Redirects to the UTLogin logout resource.
 *
 * This page callback redirects the user to the (external) UTLogin logout
 * resource with a further redirect destination specified as an absolute URL.
 *
 * @see utlogin_menu()
 * @see utlogin_set_skip_parameter()
 */
function utlogin_user_utlogin_logout_page() {
  if (isset($_GET['goto']) && utlogin_is_valid_goto($_GET['goto'])) {
    $goto = $_GET['goto'];
  }
  else {
    $goto = utlogin_get_default_logout_destination();
  }
  $goto = utlogin_set_skip_parameter($goto);

  drupal_goto(UTLOGIN_LOGOUT_URL, array('query' => array('goto' => $goto)));
}

/**
 * Page callback: Redirects to the designated UTLogin-protected path.
 *
 * This page callback definition replaces the default logic at the user/login
 * path with a redirection to user/utlogin/login, the designated UTLogin-
 * protected path. A "goto" URL parameter is set with the originally-requested
 * location.  Redirection to that originally-requested location is handled in
 * utlogin_user_utlogin_login_page().
 *
 * @see user_menu()
 * @see utlogin_menu()
 * @see utlogin_user_utlogin_login_page()
 */
function utlogin_user_login_page() {
  $options = array('absolute' => TRUE);
  if (isset($_GET['destination'])) {
    $options['query'] = array('goto' => $_GET['destination']);
    unset($_GET['destination']);
  }

  // Set the redirect destination to the designated UTLogin-protected resource,
  // effectively forcing UTLogin authentication.
  drupal_goto('user/utlogin/login', $options);
}

/**
 * Access callback: Checks if the user is anonymous or logged in as user1.
 *
 * @return bool
 *   TRUE if the user is anonymous or logged in as user1, or FALSE otherwise.
 *
 * @see utlogin_user1_access()
 */
function utlogin_anonymous_or_user1_access() {
  global $user;

  // Note: This check takes advantage of the fact that anonymous users have uid
  // 0 to simplify the conditional.
  return $user->uid < 2;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the "Add User" form for all users.
 *
 * The form is changed as follows:
 * - user name is described as UT EID
 * - user mail is removed
 * - user password is removed
 * - user notification option is removed
 *
 * @see user_register_form()
 * @see utlogin_user_account_form_validate()
 */
function utlogin_form_user_register_form_alter(&$form, &$form_state, $form_id) {
  $admin = user_access('administer users');

  if (!$admin) {
    drupal_goto(NULL);
  }

  $form['account']['name']['#title'] = t('UT EID');
  $form['account']['name']['#description'] = t('The user\'s UT EID.');
  $form['account']['name']['#access'] = $admin;

  $form['account']['mail']['#description'] = t('The user\'s e-mail address. All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive certain news or notifications by e-mail. This field cannot be modified manually; it will be filled in from UTLogin attributes when the user logs in.');
  $form['account']['mail']['#access'] = FALSE;
  $form['account']['mail']['#required'] = FALSE;

  $form['account']['pass']['#access'] = FALSE;
  $form['account']['pass']['#required'] = FALSE;

  $form['account']['notify']['#access'] = FALSE;

  // Replace the User module's user_account_form_validate() with a custom
  // validation handler.
  $validate_index = array_search('user_account_form_validate', $form['#validate']);
  if ($validate_index === FALSE) {
    $form['#validate'][] = 'utlogin_user_account_form_validate';
  }
  else {
    $form['#validate'][$validate_index] = 'utlogin_user_account_form_validate';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the "Edit User" form for non-user1 users (users who can edit profiles
 * will be presented with the default form for user1's profile).
 *
 * The form is changed as follows:
 * - user name (UT EID) is shown but not editable
 * - user mail is shown but not editable
 * - user password is removed
 * - password recovery/reset links are removed
 *
 * @see user_profile_form()
 * @see utlogin_user_account_form_validate()
 */
function utlogin_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  if ($form['#user']->uid != 1) {
    $form['account']['name']['#title'] = t('UT EID');
    $form['account']['name']['#description'] = t('The user\'s UT EID. This field cannot be modified.');
    $form['account']['name']['#attributes']['disabled'] = TRUE;
    $form['account']['name']['#required'] = FALSE;

    $form['account']['mail']['#description'] = t('The user\'s e-mail address. All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive certain news or notifications by e-mail. This field cannot be modified manually; it will be filled in from UTLogin attributes when the user logs in.');
    $form['account']['mail']['#attributes']['disabled'] = TRUE;
    $form['account']['mail']['#required'] = FALSE;

    $form['account']['pass']['#access'] = FALSE;
    $form['account']['pass']['#required'] = FALSE;

    // Remove the extra fields and validation presented to a user when editing
    // their own profile.
    if ($user->uid == $form['#user']->uid) {
      if (isset($form['account']['current_pass_required_values'])) {
        $form['account']['current_pass_required_values']['#value'] = array();
      }

      $form['account']['current_pass']['#description'] = '';
      $form['account']['current_pass']['#access'] = FALSE;
      $form['account']['current_pass']['#required'] = FALSE;
    }

    // Replace the User module's user_account_form_validate() with a custom
    // validation handler.
    $validate_index = array_search('user_account_form_validate', $form['#validate']);
    if ($validate_index === FALSE) {
      $form['#validate'][] = 'utlogin_user_account_form_validate';
    }
    else {
      $form['#validate'][$validate_index] = 'utlogin_user_account_form_validate';
    }
  }
}

/**
 * Form validation handler for user_account_form().
 *
 * This form validation handler is meant to replace user_account_form_validate().
 *
 * The user name field is validated against UT EID rules and the user mail field
 * is not validated at all.
 *
 * @see utlogin_user_validate_name()
 */
function utlogin_user_account_form_validate($form, &$form_state) {
  if ($form['#user_category'] == 'account' || $form['#user_category'] == 'register') {
    $account = $form['#user'];

    // Validate UT EID.
    if (isset($form_state['values']['name'])) {
      // Trim whitespace and force UT EID to lowercase.
      $name = trim(strtolower($form_state['values']['name']));
      form_set_value($form['account']['name'], $name, $form_state);

      if ($error = utlogin_user_validate_name($form_state['values']['name'])) {
        form_set_error('name', $error);
      }
      elseif ((bool) db_select('users')->fields('users', array('uid'))->condition('uid', $account->uid, '<>')->condition('name', db_like($form_state['values']['name']), 'LIKE')->range(0, 1)->execute()->fetchField()) {
        form_set_error('name', t('A user with UT EID %name already exists.', array('%name' => $form_state['values']['name'])));
      }
    }

    // Make sure the signature isn't longer than the size of the database field.
    // Signatures are disabled by default, so make sure it exists first.
    if (isset($form_state['values']['signature'])) {
      // Move text format for user signature into 'signature_format'.
      $form_state['values']['signature_format'] = $form_state['values']['signature']['format'];
      // Move text value for user signature into 'signature'.
      $form_state['values']['signature'] = $form_state['values']['signature']['value'];

      $user_schema = drupal_get_schema('users');
      if (drupal_strlen($form_state['values']['signature']) > $user_schema['fields']['signature']['length']) {
        form_set_error('signature', t('The signature is too long: it must be %max characters or less.', array('%max' => $user_schema['fields']['signature']['length'])));
      }
    }
  }
}

/**
 * Custom validation for a user's name (UT EID).
 *
 * This function performs the following checks on a given name:
 * - is non-empty
 * - matches the regular pattern /^([\w.-]{1,8})$/
 *
 * @param string $name
 *   The name to be checked.
 *
 * @return string|null
 *   NULL if the given name passes all checks, or an error string otherwise.
 */
function utlogin_user_validate_name($name) {
  // Check that the name is non-empty.
  if (!$name) {
    return t('You must enter a UT EID.');
  }

  // Check that the name matches the UT EID regular pattern.
  if (!preg_match('/^([\w.-]{1,8})$/', $name)) {
    return t('The entered UT EID is not valid.');
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the "Request new password" form to only allow password resets for user1.
 *
 * The form fields are left unaltered, but a custom validation handler is added
 * on.
 *
 * @see user_pass()
 * @see utlogin_user_pass_validate()
 */
function utlogin_form_user_pass_alter(&$form, &$form_state) {
  $form['#validate'][] = 'utlogin_user_pass_validate';
}

/**
 * Form validation handler for user_pass().
 *
 * This form validation handler is meant to be called after the User module's
 * user_pass_validate(). This effectively makes it so password resets through
 * the "Request new password" form can only be requested for user1.
 *
 * A retrieved user account is checked to see if it is user1.
 *
 * @see user_pass_validate()
 */
function utlogin_user_pass_validate($form, &$form_state) {
  if (isset($form_state['values']['account'])) {
    $account = $form_state['values']['account'];
    if ($account->uid != 1) {
      form_set_error('name', t('The password for %name cannot be reset.', array('%name' => $account->name)));
    }
  }
}

/**
 * Menu callback: Process a one-time login link only if it is for user1.
 *
 * If the one-time login link is for user1, the usual form response is returned,
 * otherwise, a 403 response is returned.
 *
 * @see user_pass_reset()
 */
function utlogin_user_pass_reset($form, &$form_state, $uid, $timestamp, $hashed_pass, $action = NULL) {
  if ($uid != 1) {
    // @todo: Consider replacing the 403 response with a redirect to <front>
    // with a user-friendly error message.
    drupal_access_denied();
    drupal_exit();
  }

  return drupal_get_form('user_pass_reset', $uid, $timestamp, $hashed_pass, $action);
}

/**
 * Implements hook_init().
 *
 * On every non-cached request, attempt to fetch UTLogin headers. If headers
 * are present and a UTLogin user with a name matching the EID exists, log the
 * user in using user_external_login_register().
 *
 * If auto-register is enabled, new users will be added to the system using
 * user_external_login_register(), otherwise they will remain anonymous.
 *
 * The login/auto-register process is sensitive to the presence of the skip
 * parameter; i.e., when the skip parameter is present, UTLogin headers are
 * ignored.
 *
 * If the user was successfully logged in, update the user's attributes with
 * UTLogin header values using utlogin_update_user_attributes().
 *
 * @see user_external_login_register()
 * @see utlogin_get_skip_parameter()
 * @see utlogin_get_utlogin_headers()
 * @see utlogin_update_user_attributes()
 */
function utlogin_init() {
  global $user;
  global $_utlogin_skip_logout;

  module_load_include('pages.inc', 'user');

  // Ignore UTLogin headers if the skip parameter is detected.
  if (utlogin_get_skip_parameter()) {
    $utlogin_headers = array();
  }
  else {
    $utlogin_headers = utlogin_get_utlogin_headers();
  }

  if (user_is_logged_in()) {
    // User1 has higher priority over UTLogin; disregard any further UTLogin
    // processing.
    if ($user->uid == 1) {
      return;
    }

    if ($utlogin_headers) {
      if ($user->name == $utlogin_headers['HTTP_UTLOGIN_EID']) {
        // The UTLogin user is already logged in; nothing else needs to be done.

        return;
      }
      else {
        // The Drupal user and UTLogin user do not correspond to the same person;
        // log out of the current Drupal session and process the request anew.

        $_utlogin_skip_logout = TRUE;
        user_logout();
      }
    }
    else {
      // The Drupal user should be anonymous if the webuser is not authenticated
      // with UTLogin.

      $_utlogin_skip_logout = TRUE;
      user_logout();
    }
  }
  else {
    // The user is anonymous.

    if ($utlogin_headers) {
      if (user_is_blocked($utlogin_headers['HTTP_UTLOGIN_EID'])) {
        // Inform the user that they are blocked and provide a mailto link for
        // assistance.

        $site_mail = variable_get('site_mail');
        $site_mail_link = "<a href=\"mailto:{$site_mail}\">{$site_mail}</a>";
        $message = t('Attempt to automatically log in using UTLogin credentials for %name failed, because that account has not been activated or is blocked on this site. Please contact !site_mail_link for assistance.', array('%name' => $utlogin_headers['HTTP_UTLOGIN_EID'], '!site_mail_link' => $site_mail_link));
        drupal_set_message($message, 'warning', FALSE);

        // Stop any further execution (the user remains anonymous).
        return;
      }

      if (utlogin_check_user_with_name_exists($utlogin_headers['HTTP_UTLOGIN_EID'])) {
        if (!utlogin_check_utlogin_authmap_exists($utlogin_headers['HTTP_UTLOGIN_EID'])) {
          // A non-UTLogin user account already exists with the same name. Deny
          // access but supply a help message for assistance. A site admin will
          // need to resolve the naming conflict.

          $site_mail = variable_get('site_mail');
          $site_mail_link = "<a href=\"mailto:{$site_mail}\">{$site_mail}</a>";
          $message = t('Attempt to automatically log in using UTLogin credentials for %name failed, because a non-UTLogin account with that name already exists. Please contact !site_mail_link for assistance.', array('%name' => $utlogin_headers['HTTP_UTLOGIN_EID'], '!site_mail_link' => $site_mail_link));
          drupal_set_message($message, 'warning', FALSE);

          // Stop any further execution (the user remains anonymous).
          return;
        }

        // The user already exists in the system as a UTLogin user; log them in.
        user_external_login_register($utlogin_headers['HTTP_UTLOGIN_EID'], 'utlogin');
      }
      else {
        if (variable_get('utlogin_auto_register', FALSE)) {
          // Create a new user account for the UTLogin user.
          user_external_login_register($utlogin_headers['HTTP_UTLOGIN_EID'], 'utlogin');
        }
        else {
          // Give the user feedback about why they could not be logged in.
          drupal_set_message(t('Automatic user account creation is currently disabled.'), 'error');
        }
      }

      if (user_is_logged_in()) {
        // The user has successfully logged in; update attributes from UTLogin
        // headers.
        utlogin_update_user_attributes();
      }
    }
  }

  return;
}

/**
 * Implements hook_user_logout().
 *
 * This process determines a redirect destination depending on the value of the
 * $_utlogin_skip_logout variable. The actual redirection is set up to occur in
 * the User module's user_logout() (using drupal_goto()).
 *
 * If $_utlogin_skip_logout is TRUE, the user will not be logged out of UTLogin.
 * The user will be logged out internally (Drupal) and then redirected back to
 * the current location.
 *
 * If $_utlogin_skip_logout is not TRUE, the user will be redirected to
 * user/utlogin/logout.
 *
 * @see drupal_goto()
 * @see user_logout()
 * @see utlogin_menu()
 * @see utlogin_user_utlogin_logout()
 */
function utlogin_user_logout($account) {
  global $_utlogin_skip_logout;

  if ($_utlogin_skip_logout) {
    $destination = substr(request_uri(), strlen(base_path()));
  }
  else {
    $destination = 'user/utlogin/logout';
  }

  // Set the destination in $_GET, which will be processed at the end of
  // user_logout(), allowing other hook_user_logout() implementations to run.
  $_GET['destination'] = $destination;
}

/**
 * Implements hook_views_api().
 */
function utlogin_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_mail_alter().
 *
 * Prevent e-mail from being sent to users that don't have a mail value.
 */
function utlogin_mail_alter(&$message) {
  if (empty($message['to'])) {
    $message['send'] = FALSE;
  }
}

/**
 * Implements hook_action_info().
 */
function utlogin_action_info() {
  return array(
    'utlogin_convert_local_to_utlogin_action' => array(
      'type' => 'user',
      'label' => t('Convert local users to UTLogin users'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * Custom action to convert a non-UTLogin user to a UTLogin user.
 *
 * This action is meant to be used with the custom view defined in
 * utlogin_views_default_views().
 *
 * Ensure an authmap record with module "utlogin" exists for a specified user.
 *
 * @see user_set_authmaps()
 * @see utlogin_views_default_views()
 */
function utlogin_convert_local_to_utlogin_action(&$node, $context) {
  user_set_authmaps($node, array("authname_utlogin" => $node->name));
}

/**
 * Implements hook_user_insert().
 *
 * An authmap record with module "utlogin" is added for the user. Additionally,
 * a random password is assigned to the user (for consistency with users added
 * via user_external_login_register()).
 */
function utlogin_user_insert(&$edit, $account, $category) {
  user_set_authmaps($account, array("authname_utlogin" => $account->name));

  // Ensure is_new is FALSE for the call to user_save() to prevent errors from
  // trying to insert another record for the same user.
  $original_is_new = $account->is_new;
  $account->is_new = FALSE;
  user_save($account, array('pass' => user_password()));
  $account->is_new = $original_is_new;
}
